// ============================================================
// color.v
// Controlador VGA 1280x800 + Renderizado de texto 8x16
// Compatible con top_level.sv
// ============================================================

module color(
  input clock,                 // CLOCK_50 (50 MHz)
  input reset,                 // Reset activo en alto
  input [31:0] pc_value,
  output reg [7:0] vga_red,
  output reg [7:0] vga_green,
  output reg [7:0] vga_blue,
  output vga_hsync,
  output vga_vsync,
  output vga_clock
);

  // ============================================================
  // Señales VGA
  // ============================================================
  wire [10:0] x;
  wire [9:0]  y;
  wire videoOn;
  wire vgaclk;

  // PLL VGA
  clock1280x800 vgaclock(
    .clock50(clock),
    .reset(reset),
    .vgaclk(vgaclk)
  );

  assign vga_clock = vgaclk;

  // Controlador VGA
  vga_controller_1280x800 ctrl(
    .clk(vgaclk),
    .reset(reset),
    .video_on(videoOn),
    .hsync(vga_hsync),
    .vsync(vga_vsync),
    .hcount(x),
    .vcount(y)
  );

  // ============================================================
  // Fuente 8x16
  // ============================================================
  wire [7:0] ascii_code;
  wire [3:0] row_in_char;
  wire [2:0] col_in_char;
  wire pixel_on;

  font_renderer font_inst (
      .clk(vgaclk),
      .ascii_code(ascii_code),
      .row_in_char(row_in_char),
      .col_in_char(col_in_char),
      .pixel_on(pixel_on)
  );

    // ============================================================
  // Texto dinámico: valor del PC en hexadecimal ("PC=XXXXXXXX")
  // ============================================================
  // buffer de caracteres: indices 0..10 -> "P","C","=" + 8 hex
  reg [7:0] mensaje [0:10];
  reg [31:0] pc_reg;
  reg [31:0] temp;
  reg [3:0] nibble;
  integer i;

  // estados
  parameter IDLE  = 2'd0;
  parameter UPDATE = 2'd1;
  reg [1:0] state;

  // inicialización en reset
  always @(posedge clock or posedge reset) begin
    if (reset) begin
      pc_reg <= 32'h0;
      state <= IDLE;
      // inicializa mensaje con "PC=00000000"
      mensaje[0] <= "P";
      mensaje[1] <= "C";
      mensaje[2] <= "=";
      for (i = 3; i < 11; i = i + 1)
        mensaje[i] <= "0";
    end else begin
      // detectar cambio de pc_value (pc_value proviene del top_level)
      if (pc_value != pc_reg) begin
        pc_reg <= pc_value;
        state <= UPDATE;
      end else if (state == UPDATE) begin
        state <= IDLE;
      end
    end
  end

  // cuando hay UPDATE, convierte pc_reg a ascii hex y guarda en mensaje[]
  always @(posedge clock) begin
    if (state == UPDATE) begin
      temp = pc_reg;
      // procesamos nibble por nibble desde MSB al LSB
      // mensaje[3] <- nibble[31:28], mensaje[10] <- nibble[3:0]
      for (i = 0; i < 8; i = i + 1) begin
        // obtener nibble más significativo restante
        nibble = (temp >> 28) & 4'hF;
        if (nibble < 4'd10)
          mensaje[3 + i] <= 8'd48 + nibble; // '0' + nibble
        else
          mensaje[3 + i] <= 8'd65 + (nibble - 4'd10); // 'A' + (nibble-10)
        temp = temp << 4;
      end
    end
  end

  // ============================================================
  // Posición y señales para el renderer de fuente (8x16)
  // ============================================================
  parameter TEXT_X = 400;
  parameter TEXT_Y = 300;
  parameter CHAR_W = 8;
  parameter CHAR_H = 16;

  wire [3:0] char_col;
  wire inside_text;

  assign char_col = (x >= TEXT_X && x < TEXT_X + CHAR_W * 11) ? ((x - TEXT_X) / CHAR_W) : 4'd0;
  assign inside_text = (x >= TEXT_X && x < TEXT_X + CHAR_W * 11 &&
                        y >= TEXT_Y && y < TEXT_Y + CHAR_H);

  assign row_in_char = (y - TEXT_Y) % CHAR_H;
  assign col_in_char = (x - TEXT_X) % CHAR_W;

  // ascii_code: si estamos dentro del área de texto, tomar mensaje[char_col],
  // en caso contrario enviar espacio (32)
  reg [7:0] ascii_code_reg;
  assign ascii_code = ascii_code_reg;

  always @(*) begin
    if (inside_text)
      ascii_code_reg = mensaje[char_col];
    else
      ascii_code_reg = 8'd32; // espacio
  end


  // ============================================================
  // Color de salida VGA
  // ============================================================
  always @(*) begin
    if (~videoOn)
      {vga_red, vga_green, vga_blue} = 24'h000000;
    else if (inside_text && pixel_on)
      {vga_red, vga_green, vga_blue} = 24'hFFFFFF;
    else
      {vga_red, vga_green, vga_blue} = 24'h000000;
  end

endmodule


// ============================================================
// Generador de reloj VGA
// ============================================================
module clock1280x800(clock50, reset, vgaclk);
  input clock50;
  input reset;
  output vgaclk;

  wire null;
  vgaClock clk(
    .ref_clk_clk(clock50),
    .ref_reset_reset(reset),
    .reset_source_reset(null),
    .vga_clk_clk(vgaclk)
  );
endmodule


// ============================================================
// Controlador VGA 1280x800
// ============================================================
module vga_controller_1280x800 (
  input clk,
  input reset,
  output wire hsync,
  output wire vsync,
  output reg [10:0] hcount,
  output reg [9:0]  vcount,
  output video_on
);

  parameter H_VISIBLE = 1280;
  parameter H_FP      = 48;
  parameter H_SYNC    = 32;
  parameter H_BP      = 80;
  parameter H_TOTAL   = H_VISIBLE + H_FP + H_SYNC + H_BP;

  parameter V_VISIBLE = 800;
  parameter V_FP      = 3;
  parameter V_SYNC    = 6;
  parameter V_BP      = 22;
  parameter V_TOTAL   = V_VISIBLE + V_FP + V_SYNC + V_BP;

  always @(posedge clk or posedge reset) begin
    if (reset) begin
      hcount <= 0;
      vcount <= 0;
    end else begin
      if (hcount == H_TOTAL - 1) begin
        hcount <= 0;
        if (vcount == V_TOTAL - 1)
          vcount <= 0;
        else
          vcount <= vcount + 1;
      end else begin
        hcount <= hcount + 1;
      end
    end
  end

  assign hsync = (hcount >= H_VISIBLE + H_FP) && 
                 (hcount < H_VISIBLE + H_FP + H_SYNC);
  assign vsync = (vcount >= V_VISIBLE + V_FP) && 
                 (vcount < V_VISIBLE + V_FP + V_SYNC);
  assign video_on = (hcount < H_VISIBLE) && (vcount < V_VISIBLE);
endmodule
