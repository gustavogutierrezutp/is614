// register_file.sv
// Banco de 32 registros de 32 bits.
module register_file (
    input  logic        clk,
    input  logic        we,       // Write Enable
    input  logic [4:0]  rs1_addr, // Read address 1
    input  logic [4:0]  rs2_addr, // Read address 2
    input  logic [4:0]  rd_addr,  // Write address
    input  logic [31:0] wdata,    // Write data
    output logic [31:0] rs1_data, // Read data 1
    output logic [31:0] rs2_data  // Read data 2
);

    // Array de 32 registros de 32 bits
    logic [31:0] registers[31:0];

    // Lógica de escritura (sincrónica)
    always_ff @(posedge clk) begin
        if (we && rd_addr != 5'b0) begin // Escribir si we=1 y no es el registro x0
            registers[rd_addr] <= wdata;
        end
    end

    // Lógica de lectura (asincrónica)
    // El registro x0 siempre devuelve 0
    assign rs1_data = (rs1_addr == 5'b0) ? 32'b0 : registers[rs1_addr];
    assign rs2_data = (rs2_addr == 5'b0) ? 32'b0 : registers[rs2_addr];

    // Opcional: inicializar registros para simulación
    initial begin
        for (int i = 0; i < 32; i++) begin
            registers[i] = 32'b0;
        end
        // Valores de prueba
        registers[1] = 32'd10; // x1 = 10
        registers[2] = 32'd5;  // x2 = 5
    end

endmodule