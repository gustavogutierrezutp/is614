module color(
  // Clocks and Resets
  input clock,                 // 50 MHz clock on de1-soc (ref_clk for PLL)
  input sw0,                   // System Reset (asumido como el único switch de control)
  
  // Debug Inputs from Datapath (RISC-V)
  input [31:0] pc_addr,
  input [31:0] instr,
  input [31:0] alu_result,
  input [31:0] reg_data1,       // Data read from RS1
  input [31:0] reg_data2,       // Data read from RS2
  input [31:0] rd_data,         // Data being written back to Register File
  input regWrite,              // Register Write Enable
  input MemRead,               // Data Memory Read Enable
  input MemWrite,              // Data Memory Write Enable
  
  // VGA Outputs
  output reg [7:0] vga_red,    // VGA outputs
  output reg [7:0] vga_green,
  output reg [7:0] vga_blue,
  output vga_hsync,
  output vga_vsync,
  output vga_clock
);
  
  // ------------------------------------
  // VGA CLOCK & CONTROLLER WIRES
  // ------------------------------------
  wire [10:0] x;               // Horizontal Counter
  wire [9:0] y;                // Vertical Counter
  wire videoOn;                // Visible area signal
  wire vgaclk;                 // Pixel Clock (Output from PLL)
  
  // ------------------------------------
  // PLL Instantiation
  // ------------------------------------
  clock1280x800 vgaclock(
	.clock50(clock),
	.reset(sw0), // Usando sw0 como reset del PLL
	.vgaclk(vgaclk)
  );
  
  assign vga_clock = vgaclk;
  
  // ------------------------------------
  // VGA Controller Instantiation
  // ------------------------------------
  vga_controller_1280x800 pt(
    .clk(vgaclk), 
    .reset(sw0), // Usando sw0 como reset del controlador
    .video_on(videoOn), 
    .hsync(vga_hsync), 
    .vsync(vga_vsync), 
    .hcount(x), 
    .vcount(y)
  );

  // ------------------------------------
  // TEXT DEBUG CONSTANTS AND WIRES
  // ------------------------------------
  parameter FONT_WIDTH  = 8;
  parameter FONT_HEIGHT = 8;
  
  // Color Palette (8-bit per component)
  parameter [7:0] C_BLACK   = 8'h00;
  parameter [7:0] C_WHITE   = 8'hFF;
  parameter [7:0] C_DARK_BG = 8'h20; // Dark Gray Background
  
  // Display Positions (Character Coordinates) - Separated by one empty line (16 pixels)
  parameter CHAR_COL_START = 2; // Columna inicial
  parameter CHAR_ROW_PC    = 2;
  parameter CHAR_ROW_INSTR = 4;
  parameter CHAR_ROW_ALU   = 6;
  parameter CHAR_ROW_RDAT1 = 8;
  parameter CHAR_ROW_RDAT2 = 10;
  parameter CHAR_ROW_RD_W  = 12;

  
  // Wires for Font ROM
  wire font_data; 
  wire [7:0] current_ascii_code;
  wire [2:0] pixel_offset_y = y[2:0]; // y % 8
  
  wire [10:0] char_x = x / FONT_WIDTH;
  wire [9:0] char_y = y / FONT_HEIGHT;
  
  // Font Address: [7:0] -> ASCII code, [2:0] -> Row offset
  wire [10:0] font_addr = {current_ascii_code, pixel_offset_y};
  
  // ------------------------------------
  // FONT ROM Instantiation (Requires 'font_rom' module)
  // ------------------------------------
  font_rom u_font_rom (
    .addr(font_addr),
    .data(font_data)
  );

  // ------------------------------------
  // TEXT RENDERING LOGIC
  // ------------------------------------
  
  // Determina el código ASCII a dibujar en la posición actual (char_x, char_y)
  always_comb begin
    current_ascii_code = 8'h20; // Default: Space

    case (char_y)
      CHAR_ROW_PC: begin
        if (char_x == CHAR_COL_START + 0) current_ascii_code = "P";
        else if (char_x == CHAR_COL_START + 1) current_ascii_code = "C";
        else if (char_x == CHAR_COL_START + 2) current_ascii_code = ":";
        else if (char_x >= CHAR_COL_START + 4 && char_x < CHAR_COL_START + 12) begin
          current_ascii_code = hex_to_ascii(pc_addr, char_x - (CHAR_COL_START + 4));
        end
      end
      
      CHAR_ROW_INSTR: begin
        if (char_x == CHAR_COL_START + 0) current_ascii_code = "I";
        else if (char_x == CHAR_COL_START + 1) current_ascii_code = "N";
        else if (char_x == CHAR_COL_START + 2) current_ascii_code = "S";
        else if (char_x == CHAR_COL_START + 3) current_ascii_code = "T";
        else if (char_x == CHAR_COL_START + 4) current_ascii_code = "R";
        else if (char_x == CHAR_COL_START + 5) current_ascii_code = ":";
        else if (char_x >= CHAR_COL_START + 7 && char_x < CHAR_COL_START + 15) begin
          current_ascii_code = hex_to_ascii(instr, char_x - (CHAR_COL_START + 7));
        end
      end
      
      CHAR_ROW_ALU: begin
        if (char_x == CHAR_COL_START + 0) current_ascii_code = "A";
        else if (char_x == CHAR_COL_START + 1) current_ascii_code = "L";
        else if (char_x == CHAR_COL_START + 2) current_ascii_code = "U";
        else if (char_x == CHAR_COL_START + 3) current_ascii_code = ":";
        else if (char_x >= CHAR_COL_START + 5 && char_x < CHAR_COL_START + 13) begin
          current_ascii_code = hex_to_ascii(alu_result, char_x - (CHAR_COL_START + 5));
        end
      end
      
      CHAR_ROW_RDAT1: begin
        if (char_x == CHAR_COL_START + 0) current_ascii_code = "R";
        else if (char_x == CHAR_COL_START + 1) current_ascii_code = "D";
        else if (char_x == CHAR_COL_START + 2) current_ascii_code = "A";
        else if (char_x == CHAR_COL_START + 3) current_ascii_code = "T";
        else if (char_x == CHAR_COL_START + 4) current_ascii_code = "1";
        else if (char_x == CHAR_COL_START + 5) current_ascii_code = ":";
        else if (char_x >= CHAR_COL_START + 7 && char_x < CHAR_COL_START + 15) begin
          current_ascii_code = hex_to_ascii(reg_data1, char_x - (CHAR_COL_START + 7));
        end
      end
      
      CHAR_ROW_RDAT2: begin
        if (char_x == CHAR_COL_START + 0) current_ascii_code = "R";
        else if (char_x == CHAR_COL_START + 1) current_ascii_code = "D";
        else if (char_x == CHAR_COL_START + 2) current_ascii_code = "A";
        else if (char_x == CHAR_COL_START + 3) current_ascii_code = "T";
        else if (char_x == CHAR_COL_START + 4) current_ascii_code = "2";
        else if (char_x == CHAR_COL_START + 5) current_ascii_code = ":";
        else if (char_x >= CHAR_COL_START + 7 && char_x < CHAR_COL_START + 15) begin
          current_ascii_code = hex_to_ascii(reg_data2, char_x - (CHAR_COL_START + 7));
        end
      end
      
      CHAR_ROW_RD_W: begin
        if (char_x == CHAR_COL_START + 0) current_ascii_code = "R";
        else if (char_x == CHAR_COL_START + 1) current_ascii_code = "D";
        else if (char_x == CHAR_COL_START + 2) current_ascii_code = "_";
        else if (char_x == CHAR_COL_START + 3) current_ascii_code = "W";
        else if (char_x == CHAR_COL_START + 4) current_ascii_code = ":";
        else if (char_x >= CHAR_COL_START + 6 && char_x < CHAR_COL_START + 14) begin
          current_ascii_code = hex_to_ascii(rd_data, char_x - (CHAR_COL_START + 6));
        end
      end
      
      default: current_ascii_code = 8'h20; // Space
    endcase
  end

  // ------------------------------------
  // PIXEL COLOR ASSIGNMENT LOGIC (SOLO DEBUG)
  // ------------------------------------

  always @* begin
    if (~videoOn) begin
      {vga_red, vga_green, vga_blue} = 24'h000000;
    end else begin 
      
      // 1. Set Debug Background Color (Dark Gray)
      {vga_red, vga_green, vga_blue} = {C_DARK_BG, C_DARK_BG, C_DARK_BG};
      
      // 2. Overlay Text Foreground
      // Comprueba si el pixel actual está en un área de texto y si el bit de la fuente está activo
      if ( (char_y >= CHAR_ROW_PC && char_y <= CHAR_ROW_RD_W) && 
           (font_data == 1'b1) ) begin
        // Foreground Color: White
        {vga_red, vga_green, vga_blue} = {C_WHITE, C_WHITE, C_WHITE};
      end
      
      // 3. Control Signal Indicator (Top Left - 4x4 characters grid)
      // Indica las señales de control en las primeras 4 filas y 4 columnas
      if (char_y < 4 && char_x < 4) begin
        
        // Fila 0: RegWrite / MemRead
        if (char_y == 0 && char_x == 0 && regWrite) begin {vga_red, vga_green, vga_blue} = 24'h00FF00; end // Green for RegWrite (PC, Instrucción)
        else if (char_y == 0 && char_x == 1 && MemRead) begin {vga_red, vga_green, vga_blue} = 24'h0000FF; end // Blue for MemRead (Memoria de Datos)
        
        // Fila 1: MemWrite
        else if (char_y == 1 && char_x == 0 && MemWrite) begin {vga_red, vga_green, vga_blue} = 24'hFF0000; end // Red for MemWrite (Memoria de Datos)
        
      end
      
    end
  end
  
  // ------------------------------------
  // Helper Function: Hex to ASCII Conversion
  // ------------------------------------
  function [7:0] hex_to_ascii;
    input [31:0] value;
    input [3:0] hex_pos; 
    
    reg [3:0] hex_val;
    
    begin
      // Extract the 4 bits corresponding to the hex_pos (0=MSB to 7=LSB)
      hex_val = value[31 - (hex_pos * 4) : 28 - (hex_pos * 4)];
      
      // Convert 4-bit hex value to 8-bit ASCII character
      case (hex_val)
        4'h0: hex_to_ascii = "0";
        4'h1: hex_to_ascii = "1";
        4'h2: hex_to_ascii = "2";
        4'h3: hex_to_ascii = "3";
        4'h4: hex_to_ascii = "4";
        4'h5: hex_to_ascii = "5";
        4'h6: hex_to_ascii = "6";
        4'h7: hex_to_ascii = "7";
        4'h8: hex_to_ascii = "8";
        4'h9: hex_to_ascii = "9";
        4'hA: hex_to_ascii = "A";
        4'hB: hex_to_ascii = "B";
        4'hC: hex_to_ascii = "C";
        4'hD: hex_to_ascii = "D";
        4'hE: hex_to_ascii = "E";
        4'hF: hex_to_ascii = "F";
        default: hex_to_ascii = "X";
      endcase
    end
  endfunction

endmodule
